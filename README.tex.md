# Курсовая работа по дисциплине "Архитектура вычислительных систем" по теме "Решение задачи Коши на GPU при помощи API Metal" 

## Введение

Дифференциальные уравнения находят применение в различных областях науки: многие физические законы являются дифференциальными уравнениями, относительно некоторых функций; в биологии они используются, например, для описания популяции; широкое применение они находят и в моделях экономической динамики.

С ростом количества входных данных ставится вопрос о ускорении численного решения дифференциальных уравнений, а также их систем.

Целью данной работы ставится рассмотрение возможности распараллеливания решения задачи Коши для однородного дифференицального уравнения (ОДУ) первого порядка вида: 

$$
\begin{cases} y' = f(t, y(t)), t_0 \le t \le t_M \\ y(t_0) = y_0 \end{cases} (1)
$$

Распараллеливание будет проведено с использованием графического процессора (GPU), так как он имеет значительное преимущество перед CPU при параллельной обработке большого набора информации.

В качестве программного обеспечения будет использован фреймворк Metal, как современный инструмент для папаллельных вычислений для платформ Apple.

Использованные аппаратные средства:

CPU - Intel Core i5 2.7 GHz (dual core)

GPU - Intel Iris Graphics 6100 1536 MB

## Краткий план

Работа состоит из двух частей:

1. Реализация метода последовательных приближений Пикара для решения задачи Коши в 2 вариантах: последовательном и параллельном. Сравнение производительности.
2. Реализация параллельного алгоритма Parareal. Анализ производительности.

## Часть 1. Метод последовательных приближений Пикара.

Метод последовательных приближений Пикара - один из алгоритмов для решения задачи Коши, который можно распараллелить по времени. Это означает, что вся область поиска решения задачи разбивается на подобласти, количество которых совпадает с количеством задействованных потоков. В каждой подобласти $[\tau_\mu, \tau_{\mu+1}]$ задача Коши решается одновременно и независимо используя заранеее найденное приближенное решение задачи при t = $\tau_\mu$.
Для ознакомления с этим методом была использована книга "Методы параллельных вычислений" (3, стр. 169-172), где можно найти более подробное описание алгоритма.
Для начала рассмотрим последовательный вариант алгоритма.

### 1.1. Последовательный алгоритм.
Рассматриваем задачу Коши (1).
Интегрируя ДУ, заменим задачу эквивалетным интегральным уравнением:
$$
y(t) = y_0 + \int_{a}^{t}f(\tau, y(\tau)d\tau
$$

Решая уравнение методом последовательных приближений, получим итерационный процесс Пикара:
$$
y^{(k)}(t) = y_0 + \int_{a}^{t}f(\tau, y^{(k-1)}(\tau)d\tau, y^{(0)}(t)=y_0
$$

Численная реализация метода выполняется с помощью квадратурных формул.
Пусть $y^{(k)}_m$ - приближенное решение задачи Коши в узле $t_m$ на k-й итерации. Используя квадратурную формулу трапеций получим:
$$
y^{(k)}_{m+1} = y^{(k)}_{m} + I^{(k-1)}_{m}; y^{(0)}_{m} = y_0;
$$

$$
I^{(k-1)}_{m} = \frac{t_{m+1} - t_m}{2}\cdot(f(t_m, y^{(k-1)}_{m}) + f(t_{m+1}, y^{(k-1)}_{m+1})
$$

Итерационный процесс прекращается при достижении заданной точности, например при $||y^{(k+1)}_{m} - y^{(k)}_{m}|| < \varepsilon$

### 1.2. Параллельный алгоритм.

Область поиска решенния $[t_0, t_M]$ разобьем на непересекающиеся подобласти $[t_\mu, t_{\mu+1}]$ ($\mu$ = 0,...,p+1) количество которых совпадает с количеством потоков p. На каждом интервале приближенное решение расчитывается в M/p узлах.

На каждой k-й итерации $\mu$-й поток выполняет следующие действия:
1. Одновременно с другими потоками вычисляет значения определенных интегралов $I^{(k-1)}_{l+\mu M/p}$, l = 0,...,M/p-1 своей подобласти по квадратурной формуле. 
2. Выполняет суммирование полученных значений и осуществляет пересылку расчитанных сумм потокам с номерами больше $\mu$.
3. Получив значения, производит вычисление $y^{(k)}_{\mu M/p}$, а также все значения приближенного решения в своей подобласти: $$y^{(k)}_{l + 1 + \mu M/p} = y^{(k)}_{l + \mu M/p} + I^{(k-1)}_{l+\mu M/p}, l = 0,1,2,M/p-1$$

Наглядно алгоритм можно увидеть на изображении:
![Параллельный метод последовательных приближений Пикара](photos/picards.png)

Точность вычислений в методе Пикара существенно зависит от величины интервала интегрирования $[t_0, t_M]$ и может быть повышена за счет применения адаптивных квадратурных формул.

### 1.3. Сравнение производительности программных реализаций.

Последовательный алгоритм был реализован с использованием языка C, а паралельный с использованием Objective C + Metal.
После нахождения оптимального количества потоков удалось добиться ускорения в среднем в 3 раза по сравнению с последовательным алгоритмом.

Для демонстрации возьмем следующую задачу Коши:

$$
\begin{cases} y' = \frac{2xy}{1+x^2}, 0 \le x \le 10 \\ y(0) = 1 \end{cases}
$$

Аналитическим решением которого является функция y(x) = 1 + $x^2$.

Область решения разбивалась на $2^{20}$ точек. Количество потоков в параллельном алгоритме - 512. Итерационный процесс заканчивался, когда максимум разностей предыдущего и текущего решения в каждой точке становился меньше 0.0001.
Было измерено время нахождения решения 50 уравнений каждого алгоритма. Результат:
![Параллельный метод последовательных приближений Пикара. Производительность](photos/picards_measure.png)

где y[$x_n$] - значения y в последней точке интервала. Необходимы для того, чтобы сверять, корректны ли найденные ответы.

Можно заметить, что при реализации параллельного метода после того как потоки параллельно высчитали значения интегралов и их сумму происходит перессылка суммы следующим потокам. Эта операция выполняется последовательно в промежутке между итерациями за $O(p^2)$, где p - число потоков. Поэтому с некоторого достаточно большого количества потоков, алгоритм может начать терять свою производительность и вовсе начать выполняться медленее последовательной версии.

## Часть 2. Алгоритм Parareal.

Parareal - параллельный алгоритм численного анализа, используемый для решения задач Коши. Изобретен в 2001 году. Также как и метод последовательных приближений Пикара является алгоритмом с временным параллелизмом.
Рассмотрим описание алгоритма, а также его программную реализацию.

### 2.1. Описание алгоритма Parareal.

Алгоритм основан на итеративном применении двух методов интегрирования. Один из них, обозначим как F, должен иметь высокую точность и соответственно высокие вычислительные затраты. Второй, обозначим как G, наоборот должен быть вычислительно дешевым, но может иметь малую точность.

Как и в предыдущем алгоритме разбиваем область поиска на подобласти $[\tau_\mu, \tau_{\mu+1}]$, с количеством равным количеству потоков. Далее сначала на каждой итерации с помощью дешевого алгоритма G вычисляем значения функции в граничных узлах. Этот алгоритм используем большой шаг равный длине подобласти, который обозначим за h. После чего, зная значения функции в граничных узлах, каждую подобласть разбиваем с помощью некоторого малого шага t на еще более мелкие подобласти и параллельно вычисляем значения для каждой подобласти $[\tau_\mu, \tau_{\mu+1}]$ с шагом t. В итоге в граничных узлах мы получили 2 значения функции - решения с использованием дешевого алгоритма с большим шагом $F(y_\mu, \tau_\mu, \tau_{\mu+1})$ и более точного алгоритма с меньшим шагом $G(y_\mu, \tau_\mu, \tau_{\mu+1})$. Находим дефект: $\delta = F(y_\mu, \tau_\mu, \tau_{\mu+1}) - G(y_\mu, \tau_\mu, \tau_{\mu+1})$, который будет использоваться для вычисления значения функции в граничных узлах в следующей итерации.

Следующая итерация начинается с нахождения граничных значений по следующей формуле:

$$
y^{k+1}_{\mu+1} = G(y_\mu^{k+1}, \tau_\mu, \tau_{\mu+1}) + F(y_\mu^{k}, \tau_\mu, \tau_{\mu+1}) - G(y_\mu^{k}, \tau_\mu, \tau_{\mu+1})
$$
или
$$
y^{k+1}_{\mu+1} = G(y_\mu^{k+1}, \tau_\mu, \tau_{\mu+1}) + \delta
$$

Продолжаем итерации, пока не получим необходимую точность.

Хорошую визуализацию алгоритма можно посмотреть в статье на [Википедии](https://en.wikipedia.org/wiki/Parareal).

### 2.2. Программная реализация.

В качестве точного метода был выбран метод Рунге-Кутта 4-го порядка. В качестве менее затратного метод Рунге-Кутта 2-го порядка.

С теми же входными данными, что и в пункте 1 получился следующий результат:

![Parareal. Производительность](photos/parareal_measure.png)

Получилось, что данный алгоритм быстрее в среднем быстрее в 2 раза, чем метод Пикара. Но его недостаток в том, что на некоторых входных данных могут возникать проблемы в сходимости. Решалось это следующим образом - итерации продолжались до тех пор, пока точность с каждой следующей итерацией повышалась. Как только наступала итерация, при которой точность начинала падать, решение останавливалось и предыдущее решение выдавалось как максимально точное. Понятно, что при таком подходе не всегда можно достичь заданной точности. Подробнее о вопросах сходимости метода можно прочесть в источниках 4-6.

### Сравненее методов:

1. Интервал - [0, 100]. Количество точек - 1024 * 16. Количество потоков - 1024.

![Plot 1](photos/plot1.png)

2. Интервал - [0, 100]. Количество точек - 1024. Количество потоков - 128.

![Plot 1](photos/plot2.png)

Как видно, при достаточно малом шаге оба метода ведут себя хорошо. Но при увеличении шага и уменьшении количества потоков метод Parareal становится менее точным, чем метод Пикара. Такое поведение может наблюдаться при различных входных данных. Но его преимуществом является его быстрота.

Графики были построены с использованием Python на основании данных, полученных с каждой из программ.

## Использованные источники:

1. [Официальная докуметация по Metal](https://developer.apple.com/documentation/metal)
2. [Примеры программ с использованием Metal](https://developer.apple.com/metal/sample-code/)
3. [Методы параллельных вычислений (А. В. Старченко, В. Н. Берцун)](http://math.tsu.ru/sites/default/files/mmf2/e-resources/parallel_comp_meth.pdf)
4. [Parareal Methods (Scott Field)](http://www.cfm.brown.edu/people/jansh/page5/page10/page40/assets/Field_Talk.pdf)
5. [Статья на википедии о алгоритме Parareal](https://en.wikipedia.org/wiki/Parareal)
6. [Realtime Computing with the Parareal Algorithm (Christopherr Harden)](http://diginole.lib.fsu.edu/islandora/object/fsu:182428/datastream/PDF/view)
