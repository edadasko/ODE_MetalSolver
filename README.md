# Курсовая работа по дисциплине "Архитектура вычислительных систем" по теме "Решение задачи Коши на GPU при помощи API Metal" 

## Введение

Дифференциальные уравнения находят применение в различных областях науки: многие физические законы являются дифференциальными уравнениями, относительно некоторых функций; в биологии они используются, например, для описания популяции; широкое применение они находят и в моделях экономической динамики.

С ростом количества входных данных ставится вопрос о ускорении численного решения дифференциальных уравнений, а также их систем.

Целью данной работы ставится рассмотрение возможности распараллеливания решения задачи Коши для однородного дифференицального уравнения (ОДУ) первого порядка вида: 

<p align="center"><img src="/tex/be6557896952888bc2682d1e35c239ba.svg?invert_in_darkmode&sanitize=true" align=middle width=244.70672654999998pt height=49.315569599999996pt/></p>

Распараллеливание будет проведено с использованием графического процессора (GPU), так как он имеет значительное преимущество перед CPU при параллельной обработке большого набора информации.

В качестве программного обеспечения будет использован фреймворк Metal, как современный инструмент для папаллельных вычислений для платформ Apple.

Использованные аппаратные средства:

CPU - Intel Core i5 2.7 GHz (dual core)

GPU - Intel Iris Graphics 6100 1536 MB

## Краткий план

Работа состоит из двух частей:

1. Реализация метода последовательных приближений Пикара для решения задачи Коши в 2 вариантах: последовательном и параллельном. Сравнение производительности.
2. Реализация параллельного алгоритма Parareal. Анализ производительности.

## Часть 1. Метод последовательных приближений Пикара

Метод последовательных приближений Пикара - один из алгоритмов для решения задачи Коши, который можно распараллелить по времени. Это означает, что вся область поиска решения задачи разбивается на подобласти, количество которых совпадает с количеством задействованных потоков. В каждой подобласти <img src="/tex/8ae66cdc371e4f00d2e41f04dac6ab11.svg?invert_in_darkmode&sanitize=true" align=middle width=65.08399919999998pt height=24.65753399999998pt/> задача Коши решается одновременно и независимо используя заранеее найденное приближенное решение задачи при t = <img src="/tex/88cb7a135ab1e05d9035cfccfa1699d0.svg?invert_in_darkmode&sanitize=true" align=middle width=15.17896214999999pt height=14.15524440000002pt/>.
Для ознакомления с этим методом была использована книга "Методы параллельных вычислений" (3, стр. 169-172), где можно найти более подробное описание алгоритма.
Для начала рассмотрим последовательный вариант алгоритма.

### 1.1. Последовательный алгоритм
Рассматриваем задачу Коши (1).
Интегрируя ДУ, заменим задачу эквивалетным интегральным уравнением:
<p align="center"><img src="/tex/aae492165fe6be11065a6d1ce83e292d.svg?invert_in_darkmode&sanitize=true" align=middle width=189.51306824999998pt height=40.36570395pt/></p>

Решая уравнение методом последовательных приближений, получим итерационный процесс Пикара:
<p align="center"><img src="/tex/b02a46612aa287626bbba835b80b4e7e.svg?invert_in_darkmode&sanitize=true" align=middle width=331.00499025pt height=40.36570395pt/></p>

Численная реализация метода выполняется с помощью квадратурных формул.
Пусть <img src="/tex/60559a136e9299807d07155e083eaf59.svg?invert_in_darkmode&sanitize=true" align=middle width=26.189268599999988pt height=34.337843099999986pt/> - приближенное решение задачи Коши в узле <img src="/tex/9f40ef19232722eb77473049a513a4ff.svg?invert_in_darkmode&sanitize=true" align=middle width=17.60094764999999pt height=20.221802699999984pt/> на k-й итерации. Используя квадратурную формулу трапеций получим:
<p align="center"><img src="/tex/41a10d2c4e4e191b57d55185c9df93de.svg?invert_in_darkmode&sanitize=true" align=middle width=225.43589144999999pt height=22.9222455pt/></p>

<p align="center"><img src="/tex/c9ed6536e0126b8106e31181643d2331.svg?invert_in_darkmode&sanitize=true" align=middle width=382.48649009999997pt height=32.50746015pt/></p>

Итерационный процесс прекращается при достижении заданной точности, например при <img src="/tex/8aa94734411e04756b0aa4e2125f98ae.svg?invert_in_darkmode&sanitize=true" align=middle width=138.60547799999998pt height=34.337843099999986pt/>

### 1.2. Параллельный алгоритм

Область поиска решенния <img src="/tex/912026ed585bf974d2e4fbf668aa6352.svg?invert_in_darkmode&sanitize=true" align=middle width=50.27633489999999pt height=24.65753399999998pt/> разобьем на непересекающиеся подобласти <img src="/tex/66aad7021c319800c1d6ad99b215f85e.svg?invert_in_darkmode&sanitize=true" align=middle width=62.58398189999999pt height=24.65753399999998pt/> (<img src="/tex/07617f9d8fe48b4a7b3f523d6730eef0.svg?invert_in_darkmode&sanitize=true" align=middle width=9.90492359999999pt height=14.15524440000002pt/> = 0,...,p+1) количество которых совпадает с количеством потоков p. На каждом интервале приближенное решение расчитывается в M/p узлах.

На каждой k-й итерации <img src="/tex/07617f9d8fe48b4a7b3f523d6730eef0.svg?invert_in_darkmode&sanitize=true" align=middle width=9.90492359999999pt height=14.15524440000002pt/>-й поток выполняет следующие действия:
1. Одновременно с другими потоками вычисляет значения определенных интегралов <img src="/tex/8d8e51f86b353fd306e5f8f54c272a17.svg?invert_in_darkmode&sanitize=true" align=middle width=56.107410149999986pt height=34.337843099999986pt/>, l = 0,...,M/p-1 своей подобласти по квадратурной формуле. 
2. Выполняет суммирование полученных значений и осуществляет пересылку расчитанных сумм потокам с номерами больше <img src="/tex/07617f9d8fe48b4a7b3f523d6730eef0.svg?invert_in_darkmode&sanitize=true" align=middle width=9.90492359999999pt height=14.15524440000002pt/>.
3. Получив значения, производит вычисление <img src="/tex/f5003343b3e4f70eced0136b00aad595.svg?invert_in_darkmode&sanitize=true" align=middle width=42.62562974999999pt height=34.337843099999986pt/>, а также все значения приближенного решения в своей подобласти: <p align="center"><img src="/tex/e4062c0338f28569790c6689ce9c098b.svg?invert_in_darkmode&sanitize=true" align=middle width=373.76103435pt height=25.643694449999998pt/></p>

Наглядно алгоритм можно увидеть на изображении:
![Параллельный метод последовательных приближений Пикара](photos/picards.png)

Точность вычислений в методе Пикара существенно зависит от величины интервала интегрирования <img src="/tex/912026ed585bf974d2e4fbf668aa6352.svg?invert_in_darkmode&sanitize=true" align=middle width=50.27633489999999pt height=24.65753399999998pt/> и может быть повышена за счет применения адаптивных квадратурных формул.

### 1.3. Сравнение производительности программных реализаций

Последовательный алгоритм был реализован с использованием языка C, а паралельный с использованием Objective C + Metal.
После нахождения оптимального количества потоков удалось добиться ускорения в среднем в 3 раза по сравнению с последовательным алгоритмом.

Для демонстрации возьмем следующую задачу Коши:

<p align="center"><img src="/tex/f5dd951e667ed85d6e7a0150095445b7.svg?invert_in_darkmode&sanitize=true" align=middle width=168.0736035pt height=49.315569599999996pt/></p>

Аналитическим решением которого является функция y(x) = 1 + <img src="/tex/6177db6fc70d94fdb9dbe1907695fce6.svg?invert_in_darkmode&sanitize=true" align=middle width=15.94753544999999pt height=26.76175259999998pt/>.

Область решения разбивалась на <img src="/tex/1131f55f436cf2a4c5c9222109756439.svg?invert_in_darkmode&sanitize=true" align=middle width=21.324302999999993pt height=26.76175259999998pt/> точек. Количество потоков в параллельном алгоритме - 512. Итерационный процесс заканчивался, когда максимум разностей предыдущего и текущего решения в каждой точке становился меньше 0.0001.
Было измерено время нахождения решения 50 уравнений каждого алгоритма. Результат:

![Параллельный метод последовательных приближений Пикара. Производительность](photos/picards_measure.png)

где y[<img src="/tex/d7084ce258ffe96f77e4f3647b250bbf.svg?invert_in_darkmode&sanitize=true" align=middle width=17.521011749999992pt height=14.15524440000002pt/>] - значения y в последней точке интервала. Необходимы для того, чтобы сверять, корректны ли найденные ответы.

Можно заметить, что при реализации параллельного метода после того как потоки параллельно высчитали значения интегралов и их сумму происходит перессылка суммы следующим потокам. Эта операция выполняется последовательно в промежутке между итерациями за <img src="/tex/7ee8cf33e37a517bae1597f296a85d84.svg?invert_in_darkmode&sanitize=true" align=middle width=41.425885049999984pt height=26.76175259999998pt/>, где p - число потоков. Поэтому с некоторого достаточно большого количества потоков алгоритм может начать терять свою производительность и вовсе начать выполняться медленее последовательной версии.

## Часть 2. Алгоритм Parareal

Parareal - параллельный алгоритм численного анализа, используемый для решения задач Коши. Изобретен в 2001 году. Также как и метод последовательных приближений Пикара является алгоритмом с временным параллелизмом.
Рассмотрим описание алгоритма, а также его программную реализацию.

### 2.1. Описание алгоритма Parareal

Алгоритм основан на итеративном применении двух методов интегрирования. Один из них, обозначим как F, должен иметь высокую точность и соответственно высокие вычислительные затраты. Второй, обозначим как G, наоборот должен быть вычислительно дешевым, но может иметь малую точность.

Как и в предыдущем алгоритме разбиваем область поиска на подобласти <img src="/tex/8ae66cdc371e4f00d2e41f04dac6ab11.svg?invert_in_darkmode&sanitize=true" align=middle width=65.08399919999998pt height=24.65753399999998pt/>, с количеством равным количеству потоков. Далее сначала на каждой итерации с помощью дешевого алгоритма G вычисляем значения функции в граничных узлах. Этот алгоритм используем большой шаг равный длине подобласти, который обозначим за h. После чего, зная значения функции в граничных узлах, каждую подобласть разбиваем с помощью некоторого малого шага t на еще более мелкие подобласти и параллельно вычисляем значения для каждой подобласти <img src="/tex/8ae66cdc371e4f00d2e41f04dac6ab11.svg?invert_in_darkmode&sanitize=true" align=middle width=65.08399919999998pt height=24.65753399999998pt/> с шагом t. В итоге в граничных узлах мы получили 2 значения функции - решения с использованием дешевого алгоритма с большим шагом <img src="/tex/730c555118832a3f25fcc31bdd5f0d54.svg?invert_in_darkmode&sanitize=true" align=middle width=105.77099279999997pt height=24.65753399999998pt/> и более точного алгоритма с меньшим шагом <img src="/tex/73f980e40abdbcdefa96f48ef6041fb7.svg?invert_in_darkmode&sanitize=true" align=middle width=105.84171509999997pt height=24.65753399999998pt/>. Находим дефект: <img src="/tex/697fc259c69b947a47eb5bc3e2342011.svg?invert_in_darkmode&sanitize=true" align=middle width=261.54960149999994pt height=24.65753399999998pt/>, который будет использоваться для вычисления значения функции в граничных узлах в следующей итерации.

Следующая итерация начинается с нахождения граничных значений по следующей формуле:

<p align="center"><img src="/tex/26f48def89b35275b7badfe4ca4b9892.svg?invert_in_darkmode&sanitize=true" align=middle width=429.5794074pt height=21.643711649999997pt/></p>
или
<p align="center"><img src="/tex/edbeb24b3765cd9a9d6740cef37e871e.svg?invert_in_darkmode&sanitize=true" align=middle width=205.8035826pt height=21.643711649999997pt/></p>

Продолжаем итерации, пока не получим необходимую точность.

В данном алгоритме значения функций F на каждой подобласти на каждой итерации вычисляются параллельно. Между итерациями необходимо последовательно вычислять значения функции G.

Хорошую визуализацию алгоритма можно посмотреть в статье на [Википедии](https://en.wikipedia.org/wiki/Parareal).

### 2.2. Программная реализация

В качестве точного метода был выбран метод Рунге-Кутта 4-го порядка. В качестве менее затратного метод Рунге-Кутта 2-го порядка.

С теми же входными данными, что и в пункте 1 получился следующий результат:

![Parareal. Производительность](photos/parareal_measure.png)

Получилось, что данный алгоритм быстрее в среднем быстрее в 2 раза, чем метод Пикара. Но его недостаток в том, что на некоторых входных данных могут возникать проблемы в сходимости. Решалось это следующим образом - итерации продолжались до тех пор, пока точность с каждой следующей итерацией повышалась. Как только наступала итерация, при которой точность начинала падать, решение останавливалось и предыдущее решение выдавалось как максимально точное. Понятно, что при таком подходе не всегда можно достичь заданной точности. Подробнее о вопросах сходимости метода можно прочесть в источниках 4-6.

### Сравнение методов:

1. Интервал - [0, 100]. Количество точек - 1024 * 16. Количество потоков - 1024.

![Plot 1](photos/plot1.png)

2. Интервал - [0, 100]. Количество точек - 1024. Количество потоков - 128.

![Plot 1](photos/plot2.png)

Как видно, при достаточно малом шаге оба метода ведут себя хорошо. Но при увеличении шага и уменьшении количества потоков метод Parareal становится менее точным, чем метод Пикара. Такое поведение может наблюдаться при различных входных данных. Но его преимуществом является быстрота.

Графики были построены с использованием Python на основании данных, полученных с каждой из программ.

## Использованные источники:

1. [Официальная докуметация по Metal](https://developer.apple.com/documentation/metal)
2. [Примеры программ с использованием Metal](https://developer.apple.com/metal/sample-code/)
3. [Методы параллельных вычислений (А. В. Старченко, В. Н. Берцун)](http://math.tsu.ru/sites/default/files/mmf2/e-resources/parallel_comp_meth.pdf)
4. [Parareal Methods (Scott Field)](http://www.cfm.brown.edu/people/jansh/page5/page10/page40/assets/Field_Talk.pdf)
5. [Статья на википедии о алгоритме Parareal](https://en.wikipedia.org/wiki/Parareal)
6. [Realtime Computing with the Parareal Algorithm (Christopherr Harden)](http://diginole.lib.fsu.edu/islandora/object/fsu:182428/datastream/PDF/view)
